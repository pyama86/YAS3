package handler

import (
	"context"
	"fmt"
	"log/slog"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/pyama86/YAS3/domain/entity"
	"github.com/pyama86/YAS3/domain/repository"
	"github.com/pyama86/YAS3/presentation/blocks"
	"github.com/pyama86/YAS3/presentation/postmortem"
	"github.com/slack-go/slack"
)

func timeNow() time.Time {
	loc, err := time.LoadLocation("Asia/Tokyo")
	if err != nil {
		loc = time.UTC
	}
	return time.Now().In(loc)
}

type CallbackHandler struct {
	ctx                context.Context
	repository         repository.Repository
	workSpaceURL       string
	aiRepository       *repository.AIRepository
	postmortemExporter repository.PostMortemRepositoryer
	config             *repository.Config
}

var urgencyColorMap = map[string]string{
	"none":     "#36a64f",
	"warning":  "#f2c744",
	"error":    "#f2c744",
	"critical": "#ff0000",
}

func NewCallbackHandler(
	ctx context.Context,
	repository repository.Repository,
	workSpaceURL string,
	aiRepository *repository.AIRepository,
	postmortemExporter repository.PostMortemRepositoryer,
	config *repository.Config,
) *CallbackHandler {
	return &CallbackHandler{
		ctx:                ctx,
		repository:         repository,
		aiRepository:       aiRepository,
		workSpaceURL:       workSpaceURL,
		postmortemExporter: postmortemExporter,
		config:             config,
	}
}

func (h *CallbackHandler) Handle(callback *slack.InteractionCallback) error {
	switch callback.Type {
	case slack.InteractionTypeBlockActions:
		if len(callback.ActionCallback.BlockActions) < 1 {
			return fmt.Errorf("block_actions is empty")
		}
		action := callback.ActionCallback.BlockActions[0]

		switch action.ActionID {
		case "incident_action":
			if err := h.openIncidentModal(callback.TriggerID, callback.Channel.ID); err != nil {
				return fmt.Errorf("openIncidentModal failed: %w", err)
			}

			h.repository.UpdateMessage(
				callback.Channel.ID,
				callback.Message.Timestamp,
				slack.MsgOptionBlocks(blocks.UserIsTyping(callback.User.ID)...),
			)
		case "handler_button":
			h.repository.DeleteMessage(
				callback.Channel.ID,
				callback.Message.Timestamp,
			)
			if err := h.submitHandler(callback.User.ID, callback.Channel.ID); err != nil {
				return fmt.Errorf("submitHandler failed: %w", err)
			}
		case "incident_level_button":
			h.repository.DeleteMessage(
				callback.Channel.ID,
				callback.Message.Timestamp,
			)

			slog.Info("incident_level_options", slog.Any("channelID", callback.Channel.ID), slog.Any("value", callback.ActionCallback.BlockActions[0].Value))

			if err := h.setIncidentLevel(callback.Channel.ID, callback.User.ID, callback.ActionCallback.BlockActions[0].Value); err != nil {
				return fmt.Errorf("setIncidentLevel failed: %w", err)
			}
		case "postmortem_action":
			h.repository.UpdateMessage(
				callback.Channel.ID,
				callback.Message.Timestamp,
				slack.MsgOptionText("üìù „Éù„Çπ„Éà„É¢„Éº„ÉÜ„É†„Çí‰ΩúÊàê‰∏≠...", false),
			)
			if err := h.createPostMortem(callback.Channel, callback.User); err != nil {
				return fmt.Errorf("createPostMortem failed: %w", err)
			}
		case "progress_summary_action":
			h.repository.UpdateMessage(
				callback.Channel.ID,
				callback.Message.Timestamp,
				slack.MsgOptionBlocks(blocks.ProgressSummaryLoading()...),
			)
			if err := h.createProgressSummary(callback.Channel, callback.User); err != nil {
				return fmt.Errorf("createProgressSummary failed: %w", err)
			}
		case "report_post_action":
			if err := h.postToReportChannel(callback.Channel, callback.User, callback.Message); err != nil {
				return fmt.Errorf("postToReportChannel failed: %w", err)
			}
		// Á¢∫Ë™ç„Éï„Ç©„Éº„É†„ÅÆ„Éú„Çø„É≥Âá¶ÁêÜ
		case "progress_summary_execute":
			// Á¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§
			h.repository.DeleteMessage(callback.Channel.ID, callback.Message.Timestamp)
			// ‰ΩúÊàê‰∏≠„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊñ∞Ë¶èÊäïÁ®ø
			_, loadingMsgTS, err := h.repository.PostMessage(
				callback.Channel.ID,
				slack.MsgOptionBlocks(blocks.ProgressSummaryLoading()...),
			)
			if err != nil {
				return fmt.Errorf("failed to post loading message: %w", err)
			}
			// „Çµ„Éû„É™‰ΩúÊàêÂá¶ÁêÜ„ÇíÂÆüË°å„Åó„ÄÅ‰ΩúÊàê‰∏≠„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞
			if err := h.createProgressSummaryWithUpdate(callback.Channel, callback.User, loadingMsgTS); err != nil {
				return fmt.Errorf("createProgressSummary failed: %w", err)
			}
		case "progress_summary_cancel":
			// Á¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§
			h.repository.DeleteMessage(callback.Channel.ID, callback.Message.Timestamp)
		case "recovery_execute":
			// Á¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§
			h.repository.DeleteMessage(callback.Channel.ID, callback.Message.Timestamp)
			// Âæ©ÊóßÂá¶ÁêÜ„ÇíÂÆüË°å
			if err := h.recoveryIncident(callback.User.ID, callback.Channel.ID); err != nil {
				return fmt.Errorf("recoveryIncident failed: %w", err)
			}
		case "recovery_cancel":
			// Á¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§
			h.repository.DeleteMessage(callback.Channel.ID, callback.Message.Timestamp)
		case "timekeeper_stop_execute":
			// Á¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§
			h.repository.DeleteMessage(callback.Channel.ID, callback.Message.Timestamp)
			// „Çø„Ç§„É†„Ç≠„Éº„Éë„ÉºÂÅúÊ≠¢Âá¶ÁêÜ„ÇíÂÆüË°å
			if err := h.stopTimeKeeper(callback.Channel.ID, callback.User.ID); err != nil {
				return fmt.Errorf("stopTimeKeeper failed: %w", err)
			}
		case "timekeeper_stop_cancel":
			// Á¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§
			h.repository.DeleteMessage(callback.Channel.ID, callback.Message.Timestamp)
		case "in_channel_options":
			if action.BlockID == "keeper_action" {
				currentBlocks := callback.Message.Blocks.BlockSet
				if len(currentBlocks) > 0 {
					currentBlocks = currentBlocks[:len(currentBlocks)-1]
				}

				h.repository.UpdateMessage(
					callback.Channel.ID,
					callback.Message.Timestamp,
					slack.MsgOptionBlocks(currentBlocks...),
				)

			} else {
				h.repository.DeleteMessage(
					callback.Channel.ID,
					callback.Message.Timestamp,
				)
			}
			switch callback.ActionCallback.BlockActions[0].SelectedOption.Value {
			case "recovery_incident":
				slog.Info("recovery_incident", slog.Any("channelID", callback.Channel.ID))
				// Á¢∫Ë™ç„Éï„Ç©„Éº„É†„ÇíË°®Á§∫
				_, _, err := h.repository.PostMessage(
					callback.Channel.ID,
					slack.MsgOptionBlocks(blocks.RecoveryConfirmation()...),
				)
				if err != nil {
					slog.Error("Failed to post recovery confirmation", slog.Any("err", err))
				}

			case "reopen_incident":
				slog.Info("reopen_incident", slog.Any("channelID", callback.Channel.ID))
				if err := h.reopenIncident(callback.User.ID, callback.Channel.ID); err != nil {
					return fmt.Errorf("reopenIncident failed: %w", err)
				}

			case "stop_timekeeper":
				slog.Info("stop_timekeeper", slog.Any("channelID", callback.Channel.ID))
				// Á¢∫Ë™ç„Éï„Ç©„Éº„É†„ÇíË°®Á§∫
				_, _, err := h.repository.PostMessage(
					callback.Channel.ID,
					slack.MsgOptionBlocks(blocks.TimekeeperStopConfirmation()...),
				)
				if err != nil {
					slog.Error("Failed to post timekeeper stop confirmation", slog.Any("err", err))
				}
			case "set_incident_level":
				slog.Info("set_incident_level", slog.Any("channelID", callback.Channel.ID))
				h.showIncidentLevelButtons(callback.Channel.ID)
			case "edit_incident_summary":
				slog.Info("edit_incident_summary", slog.Any("channelID", callback.Channel.ID))
				if err := h.openEditSummaryModal(callback.TriggerID, callback.Channel.ID); err != nil {
					return fmt.Errorf("openEditSummaryModal failed: %w", err)
				}
			case "create_postmortem":
				slog.Info("create_postmortem", slog.Any("channelID", callback.Channel.ID))
				if err := h.showPostMortemButton(callback.Channel.ID); err != nil {
					return fmt.Errorf("showPostMortemButton failed: %w", err)
				}
			case "create_progress_summary":
				slog.Info("create_progress_summary", slog.Any("channelID", callback.Channel.ID))
				// Á¢∫Ë™ç„Éï„Ç©„Éº„É†„ÇíË°®Á§∫
				_, _, err := h.repository.PostMessage(
					callback.Channel.ID,
					slack.MsgOptionBlocks(blocks.ProgressSummaryConfirmation()...),
				)
				if err != nil {
					slog.Error("Failed to post progress summary confirmation", slog.Any("err", err))
				}
			}

		}
	case slack.InteractionTypeViewSubmission:
		switch callback.View.CallbackID {
		case "incident_modal":
			if err := h.submitIncidentModal(callback); err != nil {
				return fmt.Errorf("submitIncidentModal failed: %w", err)
			}
		case "edit_summary_modal":
			if err := h.submitEditSummaryModal(callback); err != nil {
				return fmt.Errorf("submitEditSummaryModal failed: %w", err)
			}
		}
	}
	return nil
}

// „Ç§„É≥„Ç∑„Éá„É≥„Éà„Éè„É≥„Éâ„É©„Éº„ÅåÂøúÂãü„Åï„Çå„Åü„Çâ„ÄÅ‰øùÂ≠ò„Åó„Å¶„Éè„É≥„Éâ„É©„Å´ÂøÖË¶Å„Å™„Åì„Å®„ÇíÈÄöÁü•„Åô„Çã
func (h *CallbackHandler) submitHandler(userID, channelID string) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channelID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		return fmt.Errorf("incident is nil")
	}

	// „Ç§„É≥„Ç∑„Éá„É≥„Éà„Å´„Éè„É≥„Éâ„É©„Çí‰øùÂ≠ò„Åô„Çã
	incident.HandlerUserID = userID
	if err := h.repository.SaveIncident(h.ctx, incident); err != nil {
		return fmt.Errorf("failed to SaveIncident: %w", err)
	}

	_, _, err = h.repository.PostMessage(
		channelID,
		slack.MsgOptionBlocks(blocks.AcceptIncidentHandler(userID)...),
	)
	if err != nil {
		slog.Error("Failed to post accept incident handler message", slog.Any("err", err))
	}

	return nil
}

func (h *CallbackHandler) openIncidentModal(triggerID, channelID string) error {
	titleText := slack.NewTextBlockObject("plain_text", "üö® „Ç§„É≥„Ç∑„Éá„É≥„Éà„ÉÅ„É£„É≥„Éç„É´‰ΩúÊàê", false, false)
	submitText := slack.NewTextBlockObject("plain_text", "‚úÖ ‰ΩúÊàê", false, false)
	closeText := slack.NewTextBlockObject("plain_text", "‚ùå „Ç≠„É£„É≥„Çª„É´", false, false)

	services, err := h.repository.Services(h.ctx)
	if err != nil {
		return err
	}

	view := slack.ModalViewRequest{
		Type:            slack.ViewType("modal"),
		Title:           titleText,
		CallbackID:      "incident_modal",
		Submit:          submitText,
		Close:           closeText,
		Blocks:          blocks.CreateIncident(services),
		PrivateMetadata: channelID,
	}

	err = h.repository.OpenView(triggerID, view)
	if err != nil {
		return err
	}

	return err
}

func (h *CallbackHandler) submitIncidentModal(callback *slack.InteractionCallback) error {
	serviceID := callback.View.State.Values["service_block"]["service_select"].SelectedOption.Value
	summaryText := callback.View.State.Values["incident_summary_block"]["summary_text"].Value
	urgency := callback.View.State.Values["urgency_block"]["urgency_select"].SelectedOption.Value
	userID := callback.User.ID
	originalChannelID := callback.View.PrivateMetadata

	slog.Info("submitIncidentModal", slog.Any("serviceID", serviceID), slog.Any("summary_text", summaryText), slog.Any("urgency", urgency))

	// „ÉÅ„É£„É≥„Éç„É´‰ΩúÊàê
	num, err := strconv.Atoi(serviceID)
	if err != nil {
		return fmt.Errorf("failed to strconv.Atoi: %w", err)
	}

	service, err := h.repository.ServiceByID(h.ctx, num)
	if err != nil {
		return fmt.Errorf("failed to ServiceByID: %w", err)
	}

	prefix := ""
	if h.config != nil && h.config.ChannelPrefix != "" {
		prefix = h.config.ChannelPrefix
	}
	channelName := fmt.Sprintf("%s%s-%s", prefix, service.Name, timeNow().Format("2006-01-02"))

	slog.Info("get_channel_by_name", slog.Any("channelName", channelName))
	// „Åô„Åß„Å´Â≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØ„É¶„Éã„Éº„ÇØ„Å™ÂêçÂâç„Å´„Åô„Çã
	c, err := h.repository.GetChannelByName(channelName)
	if err != nil && err != repository.ErrSlackNotFound {
		return fmt.Errorf("failed to GetChannelByID: %w", err)
	}
	if c != nil {
		channelName = fmt.Sprintf("%s-%02d", channelName, timeNow().Unix()%100)
	}
	slog.Info("create_conversation", slog.Any("channelName", channelName))
	channel, err := h.repository.CreateConversation(slack.CreateConversationParams{
		ChannelName: channelName,
	})

	if err != nil {
		_, _, postErr := h.repository.PostMessage(
			callback.Channel.ID,
			slack.MsgOptionText(fmt.Sprintf("‚ùå „ÉÅ„É£„É≥„Éç„É´„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:%s", err), false),
		)
		if postErr != nil {
			slog.Error("Failed to post channel creation error message", slog.Any("err", postErr))
		}

		return fmt.Errorf("failed to CreateConversation: %w", err)
	}
	h.repository.FlushChannelCache()
	// „Ç§„É≥„Ç∑„Éá„É≥„Éà„Çí‰øùÂ≠ò„Åô„Çã
	incident := &entity.Incident{
		ChannelID:     channel.ID,
		ServiceID:     num,
		Description:   summaryText,
		HandlerUserID: userID,
		Urgency:       urgency,
		Level:         0,
		CreatedUserID: userID,
		StartedAt:     timeNow(),
	}
	slog.Info("save_incident", slog.Any("incident", incident))
	if err := h.repository.SaveIncident(h.ctx, incident); err != nil {
		return fmt.Errorf("failed to SaveIncident: %w", err)
	}

	urgencyText, ok := blocks.UrgencyMap[urgency]
	if !ok {
		return fmt.Errorf("invalid urgency: %s", urgency)
	}

	topic := fmt.Sprintf("„Çµ„Éº„Éì„ÇπÂêç:%s Á∑äÊÄ•Â∫¶:%s ‰∫ãË±°ÂÜÖÂÆπ:%s", service.Name, urgencyText, summaryText)
	slog.Info("set_topic_of_conversation", slog.Any("topic", topic))
	err = h.repository.SetTopicOfConversation(channel.ID, topic)
	if err != nil {
		return fmt.Errorf("failed to SetPurposeOfConversation: %w", err)
	}
	var members []string
	errMembers := []string{}
	slog.Info("get incident_team_members", slog.Int("count", len(service.IncidentTeamMembers)))
	for _, member := range service.IncidentTeamMembers {
		memberIDs, err := h.repository.GetMemberIDs(member)
		if err != nil {
			if err == repository.ErrSlackNotFound {
				slog.Error("failed to GetMemberIDs", slog.Any("err", err), slog.Any("member", member))
				errMembers = append(errMembers, member)
				continue
			}
		}
		members = append(members, memberIDs...)
	}

	if len(members) > 0 {
		slog.Info("invite_users_to_conversation", slog.Any("members", members))
		err = h.repository.InviteUsersToConversation(channel.ID, members...)
		if err != nil {
			return fmt.Errorf("failed to InviteUsersToConversation: %w", err)
		}

		_, _, err = h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionBlocks(blocks.InviteMembers(service)...),
		)
		if err != nil {
			slog.Error("Failed to post invite members message", slog.Any("err", err))
		}
	}

	if len(errMembers) > 0 {
		_, _, err := h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionText(fmt.Sprintf("‚ùå „ÉÅ„Éº„É†„É°„É≥„Éê„Éº„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:%s", strings.Join(errMembers, ",")), false),
		)
		if err != nil {
			slog.Error("Failed to post team member error message", slog.Any("err", err))
		}
	}

	attachment := slack.Attachment{
		Color:  urgencyColorMap[urgency],
		Blocks: slack.Blocks{BlockSet: blocks.IncidentCreated(summaryText, urgencyText, channel.ID, service)},
	}
	_, _, err = h.repository.PostMessage(
		channel.ID,
		slack.MsgOptionAttachments(attachment),
	)
	if err != nil {
		slog.Error("Failed to post incident created attachment", slog.Any("err", err))
	}

	// ÂÖ±Êúâ„ÉÅ„É£„É≥„Éç„É´„Å´„ÅäÁü•„Çâ„Åõ„ÇíÊäïÁ®ø
	if err := h.broadCastAnnouncement(channel.ID, attachment, service); err != nil {
		slog.Error("failed to broadCastAnnouncement", slog.Any("err", err))
	}

	_, _, err = h.repository.PostMessage(
		channel.ID,
		slack.MsgOptionBlocks(blocks.IncidentReportRequest(userID)...),
	)
	if err != nil {
		return fmt.Errorf("failed to PostMessage: %w", err)
	}

	_, _, err = h.repository.PostMessage(
		channel.ID,
		slack.MsgOptionBlocks(blocks.HandlerRecruitmentMessage()...),
	)
	if err != nil {
		slog.Error("Failed to post handler recruitment message", slog.Any("err", err))
	}

	// ÂÖÉ„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Å´„Ç§„É≥„Ç∑„Éá„É≥„Éà„ÉÅ„É£„É≥„Éç„É´„Å∏„ÅÆÁßªÂãïÊ°àÂÜÖ„ÇíÈÄÅ‰ø°
	if originalChannelID != "" && originalChannelID != channel.ID {
		moveMessage := fmt.Sprintf("üö® „Ç§„É≥„Ç∑„Éá„É≥„ÉàÂØæÂøú„ÅØ <#%s> „ÅßË°å„ÅÑ„Åæ„Åô„ÄÇÈñ¢‰øÇËÄÖ„ÅÆÊñπ„ÅØ„Åù„Å°„Çâ„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Å´„ÅîÂèÇÂä†„Åè„Å†„Åï„ÅÑ„ÄÇ", channel.ID)
		_, _, err := h.repository.PostMessage(
			originalChannelID,
			slack.MsgOptionText(moveMessage, false),
		)
		if err != nil {
			slog.Error("Failed to post move message", slog.Any("err", err))
		}
	}

	return nil
}

// ÈöúÂÆ≥„ÅåÂæ©Êóß„Åó„Åü„Çâ„Éà„Éî„ÉÉ„ÇØ„ÇíÂ§âÊõ¥„Åó„Å¶„ÄÅÂêÑÊâÄ„Å´ÈÄöÁü•„Åô„Çã
func (h *CallbackHandler) recoveryIncident(userID, channelID string) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channelID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		return fmt.Errorf("incident is nil")
	}
	if !incident.RecoveredAt.IsZero() {
		_, _, err := h.repository.PostMessage(
			channelID,
			slack.MsgOptionBlocks(blocks.AlreadyRecovered()...),
		)
		if err != nil {
			slog.Error("Failed to post already recovered message", slog.Any("err", err))
		}
		return nil
	}

	incident.RecoveredAt = timeNow()
	incident.RecoveredUserID = userID
	incident.DisableTimer = true
	if err := h.repository.SaveIncident(h.ctx, incident); err != nil {
		return fmt.Errorf("failed to SaveIncident: %w", err)
	}

	service, err := h.repository.ServiceByID(h.ctx, incident.ServiceID)
	if err != nil {
		return fmt.Errorf("failed to ServiceByID: %w", err)
	}

	channel, err := h.repository.GetChannelByID(channelID)
	if err != nil {
		return fmt.Errorf("failed to GetChannelByID: %w", err)
	}

	topic := fmt.Sprintf("„ÄêÂæ©Êóß„Äë%s", channel.Topic.Value)
	err = h.repository.SetTopicOfConversation(channel.ID, topic)
	if err != nil {
		return fmt.Errorf("failed to SetPurposeOfConversation: %w", err)
	}
	attachment := slack.Attachment{
		Color:  "#36a64f",
		Blocks: slack.Blocks{BlockSet: blocks.IncidentRecovered(userID, incident.HandlerUserID)},
	}

	_, _, err = h.repository.PostMessage(
		channelID,
		slack.MsgOptionAttachments(attachment),
	)
	if err != nil {
		slog.Error("Failed to post incident recovered message", slog.Any("err", err))
	}

	incidentLevel, err := h.repository.IncidentLevelByLevel(h.ctx, incident.Level)
	if err != nil {
		return fmt.Errorf("failed to IncidentLevelByLevel: %w", err)
	}

	attachment = slack.Attachment{
		Color: "#36a64f",
		Blocks: slack.Blocks{BlockSet: blocks.IncidentRecoverdAnnounce(
			incident.Description,
			incidentLevel.Description,
			channel.ID,
			service,
		)},
	}

	if err := h.broadCastAnnouncement(channelID, attachment, service); err != nil {
		slog.Error("failed to broadCastAnnouncement", slog.Any("err", err))
	}

	return nil
}

// „Çø„Ç§„É†„Ç≠„Éº„Éë„Éº„ÇíÂÅúÊ≠¢„Åô„Çã
func (h *CallbackHandler) stopTimeKeeper(channelID, userID string) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channelID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		return fmt.Errorf("incident is nil")
	}

	incident.DisableTimer = true
	if err := h.repository.SaveIncident(h.ctx, incident); err != nil {
		return fmt.Errorf("failed to SaveIncident: %w", err)
	}

	_, _, err = h.repository.PostMessage(
		channelID,
		slack.MsgOptionBlocks(blocks.TimeKeeperStopped(userID)...),
	)
	if err != nil {
		slog.Error("Failed to post timekeeper stopped message", slog.Any("err", err))
	}
	return nil
}

// „Ç§„É≥„Ç∑„Éá„É≥„Éà„É¨„Éô„É´„ÇíÂ§âÊõ¥„Åó„ÄÅÈÄöÁü•„Åô„Çã
func (h *CallbackHandler) setIncidentLevel(channelID, userID, level string) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channelID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		return fmt.Errorf("incident is nil")
	}

	levelInt, err := strconv.Atoi(level)
	if err != nil {
		return fmt.Errorf("failed to strconv.Atoi: %w", err)
	}
	incident.Level = levelInt
	if err := h.repository.SaveIncident(h.ctx, incident); err != nil {
		return fmt.Errorf("failed to SaveIncident: %w", err)
	}

	description := "„Çµ„Éº„Éì„Çπ„Å´ÂΩ±Èüø„Å™„Åó"
	levels := h.repository.IncidentLevels(h.ctx)
	for _, l := range levels {
		if l.Level == levelInt {
			description = l.Description
			break
		}
	}

	service, err := h.repository.ServiceByID(h.ctx, incident.ServiceID)
	if err != nil {
		return fmt.Errorf("failed to ServiceByID: %w", err)
	}

	color := "#36a64f"
	if levelInt > 0 {
		color = "#f2c744"
	}
	attachment := slack.Attachment{
		Color: color,
		Blocks: slack.Blocks{
			BlockSet: blocks.IncidentLevelUpdated(
				incident.Description,
				description,
				channelID,
				service,
			),
		},
	}

	_, _, err = h.repository.PostMessage(
		channelID,
		slack.MsgOptionBlocks(blocks.IncidentLevelChanged(userID, description)...),
	)
	if err != nil {
		slog.Error("Failed to post incident level changed message", slog.Any("err", err))
	}

	if err := h.broadCastAnnouncement(channelID, attachment, service); err != nil {
		slog.Error("failed to broadCastAnnouncement", slog.Any("err", err))
	}

	return nil
}

// „Ç§„É≥„Ç∑„Éá„É≥„Éà„É¨„Éô„É´„ÅÆÈÅ∏ÊäûËÇ¢„ÇíÊèê‰æõ„Åô„Çã
func (h *CallbackHandler) showIncidentLevelButtons(channelID string) {
	levels := h.repository.IncidentLevels(h.ctx)
	_, _, err := h.repository.PostMessage(
		channelID,
		slack.MsgOptionBlocks(blocks.IncidentLevelButtons(levels)...),
	)
	if err != nil {
		slog.Error("Failed to post incident level buttons", slog.Any("err", err))
	}
}

// „Éî„É≥„ÇíÊâì„Å§„Ç¢„Éä„Ç¶„É≥„Çπ„Çí„Åó„Å¶„ÄÅ„Éú„Çø„É≥„ÇíË°®Á§∫„Åô„Çã
func (h *CallbackHandler) showPostMortemButton(channelID string) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channelID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident.RecoveredAt.IsZero() {
		_, _, err := h.repository.PostMessage(
			channelID,
			slack.MsgOptionText("‚õîÔ∏è„Åæ„Å†„Ç§„É≥„Ç∑„Éá„É≥„Éà„ÅåÂæ©Êóß„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì", false),
		)
		if err != nil {
			slog.Error("Failed to post incident not recovered message", slog.Any("err", err))
		}
		return nil
	}

	_, _, err = h.repository.PostMessage(
		channelID,
		slack.MsgOptionBlocks(blocks.PostMortemButton()...),
	)
	if err != nil {
		slog.Error("Failed to post postmortem button", slog.Any("err", err))
	}
	return nil
}

// AI„ÇíÊ¥ªÁî®„Åó„Å¶„ÄÅ„Éù„Çπ„Éà„É¢„Éº„ÉÜ„É†„Çí‰ΩúÊàê„Åô„Çã
func (h *CallbackHandler) createPostMortem(channel slack.Channel, user slack.User) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channel.ID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident.PostMortemURL != "" {
		_, _, err := h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionText("‚õîÔ∏è„Éù„Çπ„Éà„É¢„Éº„ÉÜ„É†„ÅØÊó¢„Å´‰ΩúÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åô", false),
		)
		if err != nil {
			slog.Error("Failed to post postmortem exists message", slog.Any("err", err))
		}
		return nil
	}

	createdAt := incident.StartedAt
	recoveredAt := incident.RecoveredAt

	author := h.repository.GetUserPreferredName(&user)

	createdUser, err := h.repository.GetUserByID(incident.CreatedUserID)
	if err != nil {
		return fmt.Errorf("failed to GetUserByID: %w", err)
	}

	recoveredUser, err := h.repository.GetUserByID(incident.RecoveredUserID)
	if err != nil {
		return fmt.Errorf("failed to GetUserByID: %w", err)
	}

	pinnedMessages, err := h.repository.GetPinnedMessages(channel.ID)
	if err != nil {
		return fmt.Errorf("failed to GetPinnedMessages: %w", err)
	}

	formattedMessages := fmt.Sprintf("- %s %s„Åï„Çì„Åå„Ç§„É≥„Ç∑„Éá„É≥„Éà„ÉÅ„É£„É≥„Éç„É´„Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü\n", createdAt.Format("2006-01-02 15:04:05"), h.repository.GetUserPreferredName(createdUser))
	// - yyyy-MM-dd HH:mm:ss message„ÅÆÂΩ¢Âºè„Åß„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèñÂæó

	type message struct {
		ts   time.Time
		text string
		user string
	}

	var messages []message
	var userCache = map[string]string{}
	for _, m := range pinnedMessages {
		ts, err := parseSlackTimestamp(m.Timestamp)
		if err != nil {
			return fmt.Errorf("failed to parseSlackTimestamp: %w", err)
		}
		if userCache[m.User] == "" {
			user, err := h.repository.GetUserByID(m.User)
			if err != nil {
				return fmt.Errorf("failed to GetUserByID: %w", err)
			}
			userCache[m.User] = h.repository.GetUserPreferredName(user)
		}
		messages = append(messages, message{
			ts:   ts,
			text: m.Text,
			user: userCache[m.User],
		})
	}

	// message„ÇíÊôÇÁ≥ªÂàóÈ†Ü„Å´‰∏¶„Å≥Êõø„Åà
	sort.Slice(messages, func(i, j int) bool {
		return messages[i].ts.Before(messages[j].ts)
	})

	for _, m := range messages {
		formattedMessages += fmt.Sprintf("- %s %s:%s\n", m.ts.Format("2006-01-02 15:04:05"), m.user, m.text)
	}
	formattedMessages += fmt.Sprintf("- %s %s„Åï„Çì„Åå„Ç§„É≥„Ç∑„Éá„É≥„Éà„ÇíÂæ©Êóß„ÇíÂÆ£Ë®Ä\n", recoveredAt.Format("2006-01-02 15:04:05"), h.repository.GetUserPreferredName(recoveredUser))

	channelURL := fmt.Sprintf("%sarchives/%s", h.workSpaceURL, channel.ID)

	// „Éá„Éï„Ç©„É´„ÉàÂÄ§„ÅÆË®≠ÂÆö
	title := "‰æã: „Çµ„Éº„Éì„ÇπAPI„ÅåÂøúÁ≠îÂÅúÊ≠¢"
	summary := "‰æã: „Çµ„Éº„Éì„ÇπAPI„ÅåÂøúÁ≠î„Åó„Å™„ÅÑ"
	status := "Ëß£Ê±∫Ê∏à„Åø"
	impact := "‰æã: „Çµ„Éº„Éì„Çπ„ÅåÊñ≠Á∂öÁöÑ„Å´„ÉÄ„Ç¶„É≥„Åó„ÄÅÊúÄÂ§ß„ÅßÔºëÂâ≤„ÅÆ„É¶„Éº„Ç∂„Éº„ÅåÂΩ±Èüø„ÇíÂèó„Åë„Åæ„Åó„Åü„ÄÇ"
	rootCause := "‰æã: ExampleAPI„ÅÆ„Éê„Ç∞„ÄÅË®≠ÂÆö„Éü„Çπ"
	trigger := "‰æã: Áõ£Ë¶ñ„Ç¢„É©„Éº„Éà„ÄÅ„É¶„Éº„Ç∂„Éº„Åã„Çâ„ÅÆÂ†±Âëä"
	solution := "‰æã: Âàá„ÇäÊàª„Åó„ÄÅ„Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÂÜçËµ∑Âãï"
	actionItems := "‰æã:\n- „ÄêÊ†πÊú¨ÂØæÂøú„ÄëÂéüÂõ†„Å®„Å™„Å£„Åü„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÅÆ‰øÆÊ≠£\n- „ÄêÁ∑©ÂíåÁ≠ñ„Äë„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÅÆËøΩÂä†"
	lessonsGood := "‰æã: ËøÖÈÄü„Å™ÂØæÂøú„Å´„Çà„ÇäÂΩ±ÈüøÊôÇÈñì„ÇíÊúÄÂ∞èÈôê„Å´Êäë„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åü"
	lessonsBad := "‰æã: ÂàùÊúüÂØæÂøúÊôÇ„ÅÆÊÉÖÂ†±ÂÖ±Êúâ„Åå‰∏çÂçÅÂàÜ„Å†„Å£„Åü"
	lessensLucky := "‰æã: ÈöúÂÆ≥Áô∫Áîü„Åå„Éî„Éº„ÇØÊôÇÈñìÂ§ñ„Å†„Å£„Åü„Åü„ÇÅÂΩ±Èüø„ÅåÈôêÂÆöÁöÑ„Å†„Å£„Åü"

	postmortemFileTitle := fmt.Sprintf("postmortem-%s", channel.Name)

	if h.aiRepository != nil {
		// „Çø„Ç§„Éà„É´ÁîüÊàê
		t, err := h.aiRepository.GenerateTitle(incident.Description, formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to GenerateTitle: %w", err)
		}
		title = t
		postmortemFileTitle = fmt.Sprintf("postmortem-%s", t)

		// „Çµ„Éû„É™„ÉºÁîüÊàê
		s, err := h.aiRepository.Summarize(incident.Description, formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to Summarize: %w", err)
		}
		summary = s
		incident.Description = s

		// „Çπ„ÉÜ„Éº„Çø„ÇπÁîüÊàê
		st, err := h.aiRepository.GenerateStatus(incident.Description, formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to GenerateStatus: %w", err)
		}
		status = st

		// ÂΩ±ÈüøÂàÜÊûêÁîüÊàê
		i, err := h.aiRepository.GenerateImpact(incident.Description, formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to GenerateImpact: %w", err)
		}
		impact = i

		// Ê†πÊú¨ÂéüÂõ†ÁîüÊàê
		rc, err := h.aiRepository.GenerateRootCause(incident.Description, formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to GenerateRootCause: %w", err)
		}
		rootCause = rc

		// „Éà„É™„Ç¨„ÉºÁîüÊàê
		tr, err := h.aiRepository.GenerateTrigger(incident.Description, formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to GenerateTrigger: %w", err)
		}
		trigger = tr

		// Ëß£Ê±∫Á≠ñÁîüÊàê
		so, err := h.aiRepository.GenerateSolution(incident.Description, formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to GenerateSolution: %w", err)
		}
		solution = so

		// „Ç¢„ÇØ„Ç∑„Éß„É≥„Ç¢„Ç§„ÉÜ„É†ÁîüÊàê
		ai, err := h.aiRepository.GenerateActionItems(incident.Description, formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to GenerateActionItems: %w", err)
		}
		actionItems = ai

		// Â≠¶„Çì„Å†ÊïôË®ìÁîüÊàê
		lg, lb, ll, err := h.aiRepository.GenerateLessonsLearned(incident.Description, formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to GenerateLessonsLearned: %w", err)
		}
		lessonsGood = lg
		lessonsBad = lb
		lessensLucky = ll

		// „Çø„Ç§„É†„É©„Ç§„É≥Êï¥ÂΩ¢
		formattedMessages, err = h.aiRepository.FormatTimeline(formattedMessages)
		if err != nil {
			return fmt.Errorf("failed to FormatTimeline: %w", err)
		}
	}

	rendered := postmortem.Render(title, createdAt.Format("2006-01-02 15:04:05"), author, status, summary, impact, rootCause, trigger, solution, actionItems, lessonsGood, lessonsBad, lessensLucky, formattedMessages, channelURL)

	if h.postmortemExporter != nil {
		service, err := h.repository.ServiceByID(h.ctx, incident.ServiceID)
		if err != nil {
			slog.Error("failed to ServiceByID", slog.Any("err", err), slog.Any("serviceID", incident.ServiceID))
		}

		url, err := h.postmortemExporter.ExportPostMortem(h.ctx, postmortemFileTitle, rendered, service)
		if err != nil {
			return fmt.Errorf("failed to ExportPostMortem: %w", err)
		}
		incident.PostMortemURL = url
	} else {
		// „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åô„Çã
		url, err := h.repository.UploadFile(h.workSpaceURL, user.ID, channel.ID, postmortemFileTitle, title, rendered)
		if err != nil {
			return fmt.Errorf("failed to UploadFile: %w", err)
		}
		incident.PostMortemURL = url
	}

	_, _, err = h.repository.PostMessage(
		channel.ID,
		slack.MsgOptionText(fmt.Sprintf("‚úÖÔ∏è„Éù„Çπ„Éà„É¢„Éº„ÉÜ„É†„Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü: %s", incident.PostMortemURL), false),
	)
	if err != nil {
		slog.Error("Failed to post postmortem created message", slog.Any("err", err))
	}

	if err := h.repository.SaveIncident(h.ctx, incident); err != nil {
		return fmt.Errorf("failed to SaveIncident: %w", err)
	}
	return nil
}

func parseSlackTimestamp(ts string) (time.Time, error) {
	parts := strings.Split(ts, ".")
	if len(parts) != 2 {
		return time.Time{}, fmt.Errorf("invalid timestamp format: %s", ts)
	}

	sec, err := strconv.ParseInt(parts[0], 10, 64)
	if err != nil {
		return time.Time{}, err
	}

	fracPart := parts[1] + strings.Repeat("0", 9-len(parts[1])) // nanosecondË£úÊ≠£
	nsec, err := strconv.ParseInt(fracPart, 10, 64)
	if err != nil {
		return time.Time{}, err
	}

	loc, err := time.LoadLocation("Asia/Tokyo")
	if err != nil {
		loc = time.UTC
	}

	return time.Unix(sec, nsec).In(loc), nil
}

func (h *CallbackHandler) broadCastAnnouncement(channelID string, attachment slack.Attachment, service *entity.Service) error {
	// „Ç¢„Éä„Ç¶„É≥„Çπ„ÉÅ„É£„É≥„Éç„É´„Çí„Éû„Éº„Ç∏„Åó„Å¶ÈáçË§á„ÇíÈô§Âéª
	channels := make(map[string]bool)

	// „Çµ„Éº„Éì„ÇπÂõ∫Êúâ„ÅÆ„Ç¢„Éä„Ç¶„É≥„Çπ„ÉÅ„É£„É≥„Éç„É´„ÇíËøΩÂä†
	if service != nil {
		for _, c := range service.AnnouncementChannels {
			channels[c] = true
		}
	}

	// „Ç∞„É≠„Éº„Éê„É´„Ç¢„Éä„Ç¶„É≥„Çπ„ÉÅ„É£„É≥„Éç„É´„ÇíËøΩÂä†
	if h.config != nil {
		for _, c := range h.config.GetGlobalAnnouncementChannels(h.ctx) {
			channels[c] = true
		}
	}

	// „Éû„Éº„Ç∏„Åó„Åü„ÉÅ„É£„É≥„Éç„É´„Å´ÈÄöÁü•
	for c := range channels {
		cinfo, err := h.repository.GetChannelByName(c)
		if err != nil {
			slog.Error("failed to GetChannelByName", slog.Any("err", err), slog.Any("channel", c))
			continue
		}
		if cinfo == nil {
			continue
		}

		_, _, err = h.repository.PostMessage(
			cinfo.ID,
			slack.MsgOptionAttachments(attachment),
		)
		if err != nil {
			slog.Error("Failed to post announcement attachment", slog.Any("err", err))
		}
		_, _, err = h.repository.PostMessage(
			channelID,
			slack.MsgOptionText(fmt.Sprintf("üì¢ %s „ÉÅ„É£„É≥„Éç„É´„Å´ÈÄöÁü•„Åó„Åæ„Åó„Åü", cinfo.Name), false),
		)
		if err != nil {
			slog.Error("Failed to post notification message", slog.Any("err", err))
		}
	}
	return nil
}

// ‰∫ãË±°ÂÜÖÂÆπÁ∑®ÈõÜÁî®„ÅÆ„É¢„Éº„ÉÄ„É´„ÇíÈñã„Åè
func (h *CallbackHandler) openEditSummaryModal(triggerID, channelID string) error {
	titleText := slack.NewTextBlockObject("plain_text", "üìù ‰∫ãË±°ÂÜÖÂÆπ„ÅÆÁ∑®ÈõÜ", false, false)
	submitText := slack.NewTextBlockObject("plain_text", "‚úÖ Êõ¥Êñ∞", false, false)
	closeText := slack.NewTextBlockObject("plain_text", "‚ùå „Ç≠„É£„É≥„Çª„É´", false, false)

	// ÁèæÂú®„ÅÆ„Ç§„É≥„Ç∑„Éá„É≥„ÉàÊÉÖÂ†±„ÇíÂèñÂæó
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channelID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		return fmt.Errorf("incident is nil")
	}

	view := slack.ModalViewRequest{
		Type:            slack.ViewType("modal"),
		Title:           titleText,
		CallbackID:      "edit_summary_modal",
		Submit:          submitText,
		Close:           closeText,
		Blocks:          blocks.EditIncidentSummary(incident.Description),
		PrivateMetadata: channelID,
	}

	err = h.repository.OpenView(triggerID, view)
	if err != nil {
		return err
	}

	return nil
}

// ‰∫ãË±°ÂÜÖÂÆπÁ∑®ÈõÜ„É¢„Éº„ÉÄ„É´„ÅÆÈÄÅ‰ø°Âá¶ÁêÜ
func (h *CallbackHandler) submitEditSummaryModal(callback *slack.InteractionCallback) error {
	channelID := callback.View.PrivateMetadata
	summaryText := callback.View.State.Values["edit_summary_block"]["summary_text"].Value
	userID := callback.User.ID

	// „Ç§„É≥„Ç∑„Éá„É≥„ÉàÊÉÖÂ†±„ÇíÂèñÂæó
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channelID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		return fmt.Errorf("incident is nil")
	}

	// Âè§„ÅÑ‰∫ãË±°ÂÜÖÂÆπ„Çí‰øùÂ≠ò
	oldSummary := incident.Description

	// Êñ∞„Åó„ÅÑ‰∫ãË±°ÂÜÖÂÆπ„ÇíË®≠ÂÆö
	incident.Description = summaryText
	if err := h.repository.SaveIncident(h.ctx, incident); err != nil {
		return fmt.Errorf("failed to SaveIncident: %w", err)
	}

	// „ÉÅ„É£„É≥„Éç„É´„ÅÆ„Éà„Éî„ÉÉ„ÇØ„ÇÇÊõ¥Êñ∞
	channel, err := h.repository.GetChannelByID(channelID)
	if err != nil {
		return fmt.Errorf("failed to GetChannelByID: %w", err)
	}

	service, err := h.repository.ServiceByID(h.ctx, incident.ServiceID)
	if err != nil {
		return fmt.Errorf("failed to ServiceByID: %w", err)
	}

	urgencyText, ok := blocks.UrgencyMap[incident.Urgency]
	if !ok {
		return fmt.Errorf("invalid urgency: %s", incident.Urgency)
	}

	// „Éà„Éî„ÉÉ„ÇØ„ÇíÊõ¥Êñ∞ÔºàÂæ©ÊóßÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„ÄêÂæ©Êóß„Äë„ÅÆ„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÁ∂≠ÊåÅÔºâ
	topic := fmt.Sprintf("„Çµ„Éº„Éì„ÇπÂêç:%s Á∑äÊÄ•Â∫¶:%s ‰∫ãË±°ÂÜÖÂÆπ:%s", service.Name, urgencyText, summaryText)
	if strings.HasPrefix(channel.Topic.Value, "„ÄêÂæ©Êóß„Äë") {
		topic = fmt.Sprintf("„ÄêÂæ©Êóß„Äë%s", topic)
	}

	err = h.repository.SetTopicOfConversation(channelID, topic)
	if err != nil {
		return fmt.Errorf("failed to SetTopicOfConversation: %w", err)
	}

	// Â§âÊõ¥„ÇíÈÄöÁü•
	_, _, err = h.repository.PostMessage(
		channelID,
		slack.MsgOptionText(fmt.Sprintf("‚úÖ <@%s>„Åå‰∫ãË±°ÂÜÖÂÆπ„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü\n*Â§âÊõ¥Ââç:* %s\n*Â§âÊõ¥Âæå:* %s", userID, oldSummary, summaryText), false),
	)
	if err != nil {
		slog.Error("Failed to post summary update message", slog.Any("err", err))
	}

	// Âë®Áü•„ÉÅ„É£„É≥„Éç„É´„Å´ÈÄöÁü•
	attachment := slack.Attachment{
		Color:  "#f2c744",
		Blocks: slack.Blocks{BlockSet: blocks.IncidentSummaryUpdated(oldSummary, summaryText, channelID, service)},
	}

	if err := h.broadCastAnnouncement(channelID, attachment, service); err != nil {
		slog.Error("failed to broadCastAnnouncement", slog.Any("err", err))
	}

	return nil
}

// „Ç§„É≥„Ç∑„Éá„É≥„Éà„ÇíÂÜçÈñã„Åô„Çã
func (h *CallbackHandler) reopenIncident(userID, channelID string) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channelID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		return fmt.Errorf("incident is nil")
	}

	// Êó¢„Å´Âæ©Êóß„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Ç®„É©„Éº
	if incident.RecoveredAt.IsZero() {
		_, _, err := h.repository.PostMessage(
			channelID,
			slack.MsgOptionText("‚ö†Ô∏è „Ç§„É≥„Ç∑„Éá„É≥„Éà„ÅØ„Åæ„Å†Âæ©Êóß„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÂæ©Êóß„Åó„Å¶„ÅÑ„Å™„ÅÑ„Ç§„É≥„Ç∑„Éá„É≥„Éà„ÅØÂÜçÈñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ", false),
		)
		if err != nil {
			slog.Error("Failed to post incident not recovered message", slog.Any("err", err))
		}
		return nil
	}

	// „Ç§„É≥„Ç∑„Éá„É≥„Éà„ÇíÂÜçÈñãÁä∂ÊÖã„Å´Êõ¥Êñ∞
	incident.ReopenedAt = timeNow()
	incident.ReopenedUserID = userID
	incident.RecoveredAt = time.Time{} // Âæ©ÊóßÊôÇÂàª„Çí„É™„Çª„ÉÉ„Éà
	incident.RecoveredUserID = ""      // Âæ©ÊóßËÄÖ„Çí„É™„Çª„ÉÉ„Éà
	incident.DisableTimer = false      // „Çø„Ç§„Éû„Éº„ÇíÂÜçÈñã

	if err := h.repository.SaveIncident(h.ctx, incident); err != nil {
		return fmt.Errorf("failed to SaveIncident: %w", err)
	}

	service, err := h.repository.ServiceByID(h.ctx, incident.ServiceID)
	if err != nil {
		return fmt.Errorf("failed to ServiceByID: %w", err)
	}

	channel, err := h.repository.GetChannelByID(channelID)
	if err != nil {
		return fmt.Errorf("failed to GetChannelByID: %w", err)
	}

	// „Éà„Éî„ÉÉ„ÇØ„Åã„Çâ„ÄêÂæ©Êóß„Äë„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÂâäÈô§
	topic := strings.TrimPrefix(channel.Topic.Value, "„ÄêÂæ©Êóß„Äë")
	err = h.repository.SetTopicOfConversation(channel.ID, topic)
	if err != nil {
		return fmt.Errorf("failed to SetTopicOfConversation: %w", err)
	}

	// „ÉÅ„É£„É≥„Éç„É´ÂÜÖ„Å´ÂÜçÈñãÈÄöÁü•
	attachment := slack.Attachment{
		Color:  "#ff0000",
		Blocks: slack.Blocks{BlockSet: blocks.IncidentReopened(userID, incident.HandlerUserID)},
	}

	_, _, err = h.repository.PostMessage(
		channelID,
		slack.MsgOptionAttachments(attachment),
	)
	if err != nil {
		slog.Error("Failed to post incident reopened message", slog.Any("err", err))
	}

	// „Ç¢„Éä„Ç¶„É≥„Çπ„ÉÅ„É£„É≥„Éç„É´„Å´ÈÄöÁü•
	incidentLevel, err := h.repository.IncidentLevelByLevel(h.ctx, incident.Level)
	if err != nil {
		return fmt.Errorf("failed to IncidentLevelByLevel: %w", err)
	}

	attachment = slack.Attachment{
		Color: "#ff0000",
		Blocks: slack.Blocks{BlockSet: blocks.IncidentReopenedAnnounce(
			incident.Description,
			incidentLevel.Description,
			channel.ID,
			service,
		)},
	}

	if err := h.broadCastAnnouncement(channelID, attachment, service); err != nil {
		slog.Error("failed to broadCastAnnouncement", slog.Any("err", err))
	}

	return nil
}

// ÈÄ≤Êçó„Çµ„Éû„É™„Çí‰ΩúÊàê„Åô„Çã
func (h *CallbackHandler) createProgressSummary(channel slack.Channel, user slack.User) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channel.ID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		_, _, err := h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionText("‚ùå „Åì„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Å´„ÅØ„Ç§„É≥„Ç∑„Éá„É≥„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì", false),
		)
		if err != nil {
			slog.Error("Failed to post incident not found message", slog.Any("err", err))
		}
		return nil
	}

	// „ÉÅ„É£„É≥„Éç„É´„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèéÈõÜ
	messages, err := h.collectChannelMessages(channel.ID, incident)
	if err != nil {
		return fmt.Errorf("failed to collect channel messages: %w", err)
	}

	if len(messages) == 0 {
		_, _, err := h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionText("‚ùå ÂàÜÊûê„Åß„Åç„Çã„É°„ÉÉ„Çª„Éº„Ç∏„Åå„ÅÇ„Çä„Åæ„Åõ„Çì", false),
		)
		if err != nil {
			slog.Error("Failed to post no messages message", slog.Any("err", err))
		}
		return nil
	}

	// AI„ÅßÈÄ≤Êçó„Çµ„Éû„É™„ÇíÁîüÊàêÔºàÈ´òÂ∫¶„Å™ÂàÜÂâ≤Âá¶ÁêÜÂØæÂøúÔºâ
	summary, err := h.aiRepository.SummarizeProgressAdvanced(
		incident.Description,
		messages,
		incident.LastSummary,
	)
	if err != nil {
		// „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂæìÊù•„ÅÆÊñπÂºè„Åß„Éî„É≥„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø‰ΩøÁî®
		return h.createProgressSummaryFallback(channel, incident)
	}

	// „Çµ„Éû„É™„ÇíË°®Á§∫
	_, _, err = h.repository.PostMessage(
		channel.ID,
		slack.MsgOptionBlocks(blocks.ProgressSummary(summary)...),
	)
	if err != nil {
		return fmt.Errorf("failed to post progress summary: %w", err)
	}

	// „Ç§„É≥„Ç∑„Éá„É≥„Éà„Å´„Çµ„Éû„É™ÊÉÖÂ†±„Çí‰øùÂ≠ò
	err = h.updateIncidentSummary(incident, summary, messages)
	if err != nil {
		slog.Error("Failed to update incident summary", slog.Any("err", err))
		// „Ç®„É©„Éº„Åß„ÇÇÁ∂öË°åÔºà„Çµ„Éû„É™Ë°®Á§∫„ÅØÊàêÂäü„Åó„Åü„Åü„ÇÅÔºâ
	}

	return nil
}

// „ÉÅ„É£„É≥„Éç„É´„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèéÈõÜ
func (h *CallbackHandler) collectChannelMessages(channelID string, incident *entity.Incident) ([]slack.Message, error) {
	// ÂâçÂõûÂá¶ÁêÜÊ∏à„Åø„ÅÆ„Çø„Ç§„É†„Çπ„Çø„É≥„Éó‰ª•Èôç„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèñÂæó
	var messages []slack.Message
	var err error

	if incident.LastProcessedMessageTS != "" {
		// Â¢óÂàÜÊõ¥Êñ∞: ÂâçÂõû‰ª•Èôç„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø
		messages, err = h.repository.GetChannelMessagesAfter(channelID, incident.LastProcessedMessageTS)
	} else {
		// ÂàùÂõû‰ΩúÊàê: „Ç§„É≥„Ç∑„Éá„É≥„ÉàÈñãÂßã‰ª•Èôç„ÅÆÂÖ®„É°„ÉÉ„Çª„Éº„Ç∏
		oldest := fmt.Sprintf("%.6f", float64(incident.StartedAt.Unix()))
		messages, err = h.repository.GetChannelHistory(channelID, oldest, "", 1000)

		// „Çπ„É¨„ÉÉ„Éâ„ÇÇÂèéÈõÜ
		for _, msg := range messages {
			if msg.ThreadTimestamp != "" && msg.ThreadTimestamp == msg.Timestamp {
				replies, replyErr := h.repository.GetThreadReplies(channelID, msg.Timestamp)
				if replyErr == nil {
					// ÂÖÉ„É°„ÉÉ„Çª„Éº„Ç∏‰ª•Â§ñ„ÅÆËøî‰ø°„ÇíËøΩÂä†
					for _, reply := range replies {
						if reply.Timestamp != msg.Timestamp {
							messages = append(messages, reply)
						}
					}
				}
			}
		}
	}

	if err != nil {
		return nil, err
	}

	// „É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊôÇÁ≥ªÂàó„Åß„ÇΩ„Éº„Éà
	sort.Slice(messages, func(i, j int) bool {
		return messages[i].Timestamp < messages[j].Timestamp
	})

	return messages, nil
}

// „Ç§„É≥„Ç∑„Éá„É≥„Éà„ÅÆ„Çµ„Éû„É™ÊÉÖÂ†±„ÇíÊõ¥Êñ∞
func (h *CallbackHandler) updateIncidentSummary(incident *entity.Incident, summary string, messages []slack.Message) error {
	now := time.Now()
	incident.LastSummary = summary
	incident.LastSummaryAt = now

	// ÊúÄÂæå„Å´Âá¶ÁêÜ„Åó„Åü„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÇíÊõ¥Êñ∞
	if len(messages) > 0 {
		incident.LastProcessedMessageTS = messages[len(messages)-1].Timestamp
	}

	return h.repository.SaveIncident(h.ctx, incident)
}

// „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®„ÅÆ„Çµ„Éû„É™‰ΩúÊàêÔºàÂæìÊù•„ÅÆÊñπÂºèÔºâ
func (h *CallbackHandler) createProgressSummaryFallback(channel slack.Channel, incident *entity.Incident) error {
	slog.Warn("Using fallback progress summary method", slog.String("channelID", channel.ID))

	// „Éî„É≥„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèñÂæó
	pinnedMessages, err := h.repository.GetPinnedMessages(channel.ID)
	if err != nil {
		return fmt.Errorf("failed to GetPinnedMessages: %w", err)
	}

	// Slack„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊï¥ÂΩ¢„Åó„Å¶„Çø„Ç§„É†„É©„Ç§„É≥„Å®„Åó„Å¶Ê∏°„Åô
	var timeline strings.Builder
	for _, msg := range pinnedMessages {
		timeline.WriteString(fmt.Sprintf("%s: %s\n", msg.User, msg.Text))
	}

	// AI„ÅßÈÄ≤Êçó„Çµ„Éû„É™„ÇíÁîüÊàêÔºàÂæìÊù•„ÅÆÊñπÂºèÔºâ
	summary, err := h.aiRepository.SummarizeProgress(incident.Description, timeline.String())
	if err != nil {
		_, _, postErr := h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionText("‚ùå ÈÄ≤Êçó„Çµ„Éû„É™„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", false),
		)
		if postErr != nil {
			slog.Error("Failed to post summary generation error message", slog.Any("err", postErr))
		}
		return fmt.Errorf("failed to SummarizeProgress: %w", err)
	}

	// „Çµ„Éû„É™„ÇíË°®Á§∫
	_, _, err = h.repository.PostMessage(
		channel.ID,
		slack.MsgOptionBlocks(blocks.ProgressSummary(summary)...),
	)
	if err != nil {
		return fmt.Errorf("failed to post progress summary: %w", err)
	}

	return nil
}

// Â†±Âëä„ÉÅ„É£„É≥„Éç„É´„Å´ÊäïÁ®ø„Åô„Çã
func (h *CallbackHandler) postToReportChannel(channel slack.Channel, user slack.User, message slack.Message) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channel.ID)
	if err != nil {
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		_, _, err := h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionText("‚ùå „Åì„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Å´„ÅØ„Ç§„É≥„Ç∑„Éá„É≥„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì", false),
		)
		if err != nil {
			slog.Error("Failed to post incident not found message", slog.Any("err", err))
		}
		return nil
	}

	service, err := h.repository.ServiceByID(h.ctx, incident.ServiceID)
	if err != nil {
		return fmt.Errorf("failed to ServiceByID: %w", err)
	}

	// „Ç¢„Éä„Ç¶„É≥„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅÆÊúâÁÑ°„ÇíÁ¢∫Ë™ç
	hasAnnouncementChannels := len(service.AnnouncementChannels) > 0
	if h.config != nil {
		hasAnnouncementChannels = hasAnnouncementChannels || len(h.config.GetGlobalAnnouncementChannels(h.ctx)) > 0
	}

	if !hasAnnouncementChannels {
		_, _, err := h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionText("‚ùå „Ç¢„Éä„Ç¶„É≥„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì", false),
		)
		if err != nil {
			slog.Error("Failed to post no announcement channels message", slog.Any("err", err))
		}
		return nil
	}

	// „É°„ÉÉ„Çª„Éº„Ç∏„Éñ„É≠„ÉÉ„ÇØ„Åã„Çâ„Çµ„Éû„É™ÈÉ®ÂàÜ„ÇíÊäΩÂá∫
	var summaryText string
	var summaryParts []string

	for _, block := range message.Blocks.BlockSet {
		if sectionBlock, ok := block.(*slack.SectionBlock); ok {
			if sectionBlock.Text != nil && sectionBlock.Text.Type == "mrkdwn" {
				text := sectionBlock.Text.Text
				// „Éò„ÉÉ„ÉÄ„Éº„Éñ„É≠„ÉÉ„ÇØ„ÄÅ„Éú„Çø„É≥„Éñ„É≠„ÉÉ„ÇØ„ÄÅÂå∫Âàá„ÇäÁ∑ö„ÅØÈô§Â§ñ
				if text != "" && !strings.Contains(text, "ÈÄ≤Êçó„Çµ„Éû„É™") && !strings.Contains(text, "Â†±Âëäch„Å´ÊäïÁ®ø") {
					summaryParts = append(summaryParts, text)
				}
			}
		}
	}

	// ÂÖ®„Å¶„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÁµêÂêà„Åó„Å¶„Çµ„Éû„É™„ÉÜ„Ç≠„Çπ„Éà„Çí‰ΩúÊàê
	if len(summaryParts) > 0 {
		summaryText = strings.Join(summaryParts, "\n\n")
	}

	if summaryText == "" {
		_, _, err := h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionText("‚ùå ÊäïÁ®ø„Åô„Çã„Çµ„Éû„É™„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì", false),
		)
		if err != nil {
			slog.Error("Failed to post no summary found message", slog.Any("err", err))
		}
		return nil
	}

	// Êó¢Â≠ò„ÅÆbroadCastAnnouncementÊ©üËÉΩ„Çí‰ΩøÁî®„Åó„Å¶„Ç¢„Éä„Ç¶„É≥„Çπ„ÉÅ„É£„É≥„Éç„É´„Å´ÊäïÁ®ø
	attachment := slack.Attachment{
		Color:  "#36a64f",
		Blocks: slack.Blocks{BlockSet: blocks.ProgressSummaryAnnouncement(summaryText, channel.ID, service)},
	}

	if err := h.broadCastAnnouncement(channel.ID, attachment, service); err != nil {
		_, _, postErr := h.repository.PostMessage(
			channel.ID,
			slack.MsgOptionText("‚ùå „Ç¢„Éä„Ç¶„É≥„Çπ„ÉÅ„É£„É≥„Éç„É´„Å∏„ÅÆÊäïÁ®ø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", false),
		)
		if postErr != nil {
			slog.Error("Failed to post broadcast error message", slog.Any("err", postErr))
		}
		return fmt.Errorf("failed to broadcast progress summary: %w", err)
	}

	// ÊäïÁ®øÊàêÂäü„ÇíÈÄöÁü•
	_, _, err = h.repository.PostMessage(
		channel.ID,
		slack.MsgOptionBlocks(blocks.ReportPostSuccess("„Ç¢„Éä„Ç¶„É≥„Çπ„ÉÅ„É£„É≥„Éç„É´")...),
	)
	if err != nil {
		slog.Error("Failed to post success message", slog.Any("err", err))
	}

	return nil
}

// ÈÄ≤Êçó„Çµ„Éû„É™„Çí‰ΩúÊàê„Åó„ÄÅÊåáÂÆö„Åï„Çå„Åü„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞„Åô„Çã
func (h *CallbackHandler) createProgressSummaryWithUpdate(channel slack.Channel, user slack.User, updateMsgTS string) error {
	incident, err := h.repository.FindIncidentByChannel(h.ctx, channel.ID)
	if err != nil {
		// „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Åß‰ΩúÊàê‰∏≠„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞
		h.repository.UpdateMessage(
			channel.ID,
			updateMsgTS,
			slack.MsgOptionText("‚ùå „Ç§„É≥„Ç∑„Éá„É≥„ÉàÊÉÖÂ†±„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", false),
		)
		return fmt.Errorf("failed to FindIncidentByChannel: %w", err)
	}

	if incident == nil {
		h.repository.UpdateMessage(
			channel.ID,
			updateMsgTS,
			slack.MsgOptionText("‚ùå „Åì„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Å´„ÅØ„Ç§„É≥„Ç∑„Éá„É≥„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì", false),
		)
		return nil
	}

	// „ÉÅ„É£„É≥„Éç„É´„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèéÈõÜ
	messages, err := h.collectChannelMessages(channel.ID, incident)
	if err != nil {
		h.repository.UpdateMessage(
			channel.ID,
			updateMsgTS,
			slack.MsgOptionText("‚ùå „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂèéÈõÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", false),
		)
		return fmt.Errorf("failed to collect channel messages: %w", err)
	}

	if len(messages) == 0 {
		h.repository.UpdateMessage(
			channel.ID,
			updateMsgTS,
			slack.MsgOptionText("‚ùå ÂàÜÊûê„Åß„Åç„Çã„É°„ÉÉ„Çª„Éº„Ç∏„Åå„ÅÇ„Çä„Åæ„Åõ„Çì", false),
		)
		return nil
	}

	// AI„ÅßÈÄ≤Êçó„Çµ„Éû„É™„ÇíÁîüÊàêÔºàÈ´òÂ∫¶„Å™ÂàÜÂâ≤Âá¶ÁêÜÂØæÂøúÔºâ
	summary, err := h.aiRepository.SummarizeProgressAdvanced(
		incident.Description,
		messages,
		incident.LastSummary,
	)
	if err != nil {
		// „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂæìÊù•„ÅÆÊñπÂºè„Åß„Éî„É≥„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø‰ΩøÁî®
		return h.createProgressSummaryFallbackWithUpdate(channel, incident, updateMsgTS)
	}

	// „Çµ„Éû„É™„ÇíË°®Á§∫Ôºà‰ΩúÊàê‰∏≠„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞Ôºâ
	h.repository.UpdateMessage(
		channel.ID,
		updateMsgTS,
		slack.MsgOptionBlocks(blocks.ProgressSummary(summary)...),
	)

	// „Ç§„É≥„Ç∑„Éá„É≥„Éà„Å´„Çµ„Éû„É™ÊÉÖÂ†±„Çí‰øùÂ≠ò
	err = h.updateIncidentSummary(incident, summary, messages)
	if err != nil {
		slog.Error("Failed to update incident summary", slog.Any("err", err))
		// „Ç®„É©„Éº„Åß„ÇÇÁ∂öË°åÔºà„Çµ„Éû„É™Ë°®Á§∫„ÅØÊàêÂäü„Åó„Åü„Åü„ÇÅÔºâ
	}

	return nil
}

// „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®„ÅÆ„Çµ„Éû„É™‰ΩúÊàêÔºà‰ΩúÊàê‰∏≠„É°„ÉÉ„Çª„Éº„Ç∏Êõ¥Êñ∞ÁâàÔºâ
func (h *CallbackHandler) createProgressSummaryFallbackWithUpdate(channel slack.Channel, incident *entity.Incident, updateMsgTS string) error {
	slog.Warn("Using fallback progress summary method", slog.String("channelID", channel.ID))

	// „Éî„É≥„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèñÂæó
	pinnedMessages, err := h.repository.GetPinnedMessages(channel.ID)
	if err != nil {
		h.repository.UpdateMessage(
			channel.ID,
			updateMsgTS,
			slack.MsgOptionText("‚ùå „Éî„É≥„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", false),
		)
		return fmt.Errorf("failed to GetPinnedMessages: %w", err)
	}

	// Slack„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊï¥ÂΩ¢„Åó„Å¶„Çø„Ç§„É†„É©„Ç§„É≥„Å®„Åó„Å¶Ê∏°„Åô
	var timeline strings.Builder
	for _, msg := range pinnedMessages {
		timeline.WriteString(fmt.Sprintf("%s: %s\n", msg.User, msg.Text))
	}

	// AI„ÅßÈÄ≤Êçó„Çµ„Éû„É™„ÇíÁîüÊàêÔºàÂæìÊù•„ÅÆÊñπÂºèÔºâ
	summary, err := h.aiRepository.SummarizeProgress(incident.Description, timeline.String())
	if err != nil {
		h.repository.UpdateMessage(
			channel.ID,
			updateMsgTS,
			slack.MsgOptionText("‚ùå ÈÄ≤Êçó„Çµ„Éû„É™„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", false),
		)
		return fmt.Errorf("failed to SummarizeProgress: %w", err)
	}

	// „Çµ„Éû„É™„ÇíË°®Á§∫Ôºà‰ΩúÊàê‰∏≠„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞Ôºâ
	h.repository.UpdateMessage(
		channel.ID,
		updateMsgTS,
		slack.MsgOptionBlocks(blocks.ProgressSummary(summary)...),
	)

	return nil
}
